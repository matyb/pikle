// Defines application wide constants
package com.pk;
//import java.awt.*;

public interface Constants
{
	// Element type definitions
	int LINE = 101;
	int RECTANGLE = 102;
	int CIRCLE = 103;
	int CURVE = 104;

	// Initial conditions
	//String DEFAULT_ELEMENT_TYPE = "     ";
	String DEFAULT_ELEMENT_USER = "";

	// SQL Statements 

		String QUERYPLANSQL = //"SELECT id||'      ' id,parent_id||'      ' p_id, level||'      ' lev, lpad(operation, length(operation) + 4*(level-1)) ||\n" +
	"SELECT ' '||level||'      ' lev, lpad(operation, length(operation) + 4*(level-1)) ||\n" + "decode(id, 0, '   Optimizer='||optimizer, null) ||'  '||options||\n" + "decode(object_name,null,null,'  OF  ')||object_name||\n" + "decode(object_type,'UNIQUE', ' (U) ', 'NON-UNIQUE',\n" + "'(NU)',null) plan \n" +
		//'(Cost = '||COST||' Card='||CARDINALITY||' Bytes='||BYTES||')') plan \n"+
	"FROM   PLAN_TABLE \n" + "START with ID = 0 and STATEMENT_ID = 'pk00001' \n" + "CONNECT by prior ID = PARENT_ID and STATEMENT_ID = 'pk00001' \n";

	String DELETEPLANSQL = "DELETE FROM PLAN_TABLE";

	String DBINFOSQL = /* DB info(controlfile, logfile, datafile, tablespace)를 보여줌(size : Mbyte) */
	"SELECT 'DATA' AS KIND,TABLESPACE_NAME AS NAME, \n" + "FILE_NAME AS FILENAME, BYTES/(1024*1024) AS SZ_MB \n" + "FROM DBA_DATA_FILES \n" + "UNION ALL \n" + "SELECT 'LOG ' AS KIND,TO_CHAR(V1.GROUP#) AS NAME, \n" + "V1.MEMBER AS FILENAME, V2.BYTES/(1024*1024) AS SZ_MB \n" + "FROM V$LOGFILE V1, V$LOG V2 \n" + "WHERE V1.GROUP# = V2.GROUP# \n" + "UNION ALL \n" + "SELECT 'CTL ' AS KIND,'Control' AS NAME, \n" + "NAME AS FILENAME , 0 AS SZ_MB \n" + "FROM V$CONTROLFILE \n";

	String DFINFOSQL = /* datafile별로 size를 Mbyte단위로 보여줌 */
	"SELECT TABLESPACE_NAME AS TBS_NAME, \n" + "FILE_ID AS ID, FILE_NAME, ROUND(BYTES/(1024*1024),1) AS SZ_MB \n" + "FROM DBA_DATA_FILES " + "ORDER BY TABLESPACE_NAME,ID";

	String DFUSAGESQL = /* datafile별 usage(전체공간, 여유공간, 사용율) */
	"SELECT A.TABLESPACE_NAME, A.FILE_NAME, \n" + "ROUND(SUM(A.BYTES)/(1024.*1024.),1) AS TOT_MB, \n" + "ROUND(NVL(SUM(SZ_MB),0),1) AS FREE_MB, \n" + "ROUND(NVL(( 1. - SUM(SZ_MB)/(SUM(A.BYTES)/(1024.*1024.)) ) * 100,100),1) AS \"USAGE%\" \n" + "FROM DBA_DATA_FILES A, \n" + "( SELECT FILE_ID  , SUM(BYTES)/(1024.*1024.) AS SZ_MB \n" + "FROM DBA_FREE_SPACE \n" + "GROUP BY FILE_ID ) B \n" + "WHERE A.FILE_ID = B.FILE_ID (+) \n" + "GROUP BY A.TABLESPACE_NAME,A.FILE_NAME";

	String DBOPTIONSQL = /* 어떤 DB option이 install되어 있는지 보여줌 */
	"SELECT PARAMETER,VALUE \n" + "FROM V$OPTION \n" + "ORDER BY PARAMETER";

	String TBSGENERALSQL = /* tablespace크기,상태 및 해당 datafile의 갯수를 보여줌 */
	"SELECT A.TABLESPACE_NAME, \n" + "COUNT(*) AS DF_CNT, SUM(B.BYTES/(1024*1024)) AS SZ_MB, \n" + "MAX(A.STATUS) AS STATUS, MAX(A.CONTENTS) AS CONTENTS \n" + "FROM DBA_TABLESPACES A, DBA_DATA_FILES B " + "WHERE A.TABLESPACE_NAME = B.TABLESPACE_NAME " + "GROUP BY A.TABLESPACE_NAME ";

	String TBSUSAGESQL = /* tablespace별 usage(전체공간, 여유공간, 사용율) */
	/* 치환! 사용율(&vLIMIT)을 조건으로 조회 */
	"SELECT A.TABLESPACE_NAME, \n" + "SUM(A.BYTES)/(1024*1024) AS TOT_MB, \n" + "NVL(SUM(SZ_MB),0) AS FREE_MB, \n" + "NVL(( 1. - SUM(SZ_MB)/(SUM(A.BYTES)/(1024.*1024.)) ) * 100,100) AS \"USAGE%\" \n" + "FROM DBA_DATA_FILES A, " + "( SELECT FILE_ID  , SUM(BYTES)/(1024.*1024.) AS SZ_MB \n" + "FROM DBA_FREE_SPACE \n" + "GROUP BY FILE_ID ) B \n" + "WHERE A.FILE_ID = B.FILE_ID (+) \n" + "GROUP BY A.TABLESPACE_NAME \n" + "HAVING NVL(( 1. - SUM(SZ_MB)/(SUM(A.BYTES)/(1024.*1024.)) ) * 100,100) >= &vLIMIT ";

	String SEGLISTSQL = /* tablespace별로 segment의 정보 */
	/* (extent수,segment크기,tablespace에서의 공간차지비율)을 보여줌 */
	/* 마지막에 tablespace의 사용율을 보여줌 */
	/* tablespace별로 조건 조회 가능 */
	"SELECT NULL DUMMY, \n" + "B.TABLESPACE_NAME AS TBS_NM, \n" + "A.OWNER, \n" + "A.SEGMENT_TYPE AS TYPE, \n" + "A.SEGMENT_NAME AS NAME, \n" + "A.EXTENTS as Ext, \n" + "A.BYTES/1024 AS TOT_KB, \n" + "( A.BYTES/1024 / B.TBS_KB ) * 100 AS \"TBS USAGE%\" \n" + "FROM DBA_SEGMENTS A, \n" + "( SELECT TABLESPACE_NAME ,SUM(BYTES)/1024 AS TBS_KB \n" + "FROM DBA_DATA_FILES \n" + "WHERE TABLESPACE_NAME LIKE UPPER('&TBS_NAME')||'%' \n" + "GROUP BY TABLESPACE_NAME ) B \n" + "WHERE B.TABLESPACE_NAME = A.TABLESPACE_NAME (+) \n" + "ORDER BY TBS_NM, OWNER, SEGMENT_NAME";

	String SEGUSAGESQL = /* table, index의 storage정보 및 총사이즈, extent발생정도를 보여줌*/
	/* extent발생정도, segment_name으로 조건 조회 가능 */
	"SELECT DECODE(SIGN(EXTENTS+10-MAX_EXTENTS),1,'V') as MK, \n" + "OWNER, SEGMENT_NAME OBJECT_NAME,SEGMENT_TYPE OBJECT_TYPE, \n" + "INITIAL_EXTENT/1024 AS INI_KB, \n" + "NEXT_EXTENT/1024 AS NXT_KB , \n" + "PCT_INCREASE AS PCT, MAX_EXTENTS AS MAXT, \n" + "EXTENTS AS EXT, \n" + "BYTES/1024 AS TOT_KB, \n" + "TABLESPACE_NAME \n" + "FROM DBA_SEGMENTS \n" + "WHERE OWNER NOT IN ('SYS') \n" + "AND   SEGMENT_TYPE IN ( 'TABLE','INDEX') \n" + "AND   EXTENTS >= &extent_num \n" + "AND   SEGMENT_NAME LIKE UPPER('&seg_name')||'%' \n" + "ORDER BY OWNER, SEGMENT_NAME";

	String SEGSTORAGESQL = /* tbs_usage.sql + seg_usage */
	/* 사용율로 조건 조회 + extent발생정도로 조건 조회 가능 */
	"SELECT A.OWNER,  \n" + "A.SEGMENT_NAME,  \n" + "A.INITIAL_EXTENT/1024 AS INI_KB,  \n" + "A.NEXT_EXTENT/1024 AS NXT_KB ,  \n" + "A.PCT_INCREASE AS PCT,  \n" + "B.NUM_ROWS, A.EXTENTS AS EXT, \n" + "A.BYTES/1024 AS TOT_KB, \n" + "A.TABLESPACE_NAME  \n" + "FROM DBA_SEGMENTS A, DBA_TABLES B  \n" + "WHERE A.OWNER NOT IN ('SYS')  \n" + "AND   A.OWNER = B.OWNER(+)  \n" + "AND   A.SEGMENT_NAME = B.TABLE_NAME(+)  \n" + "AND   EXTENTS >= &extent_num  \n" + "ORDER BY A.SEGMENT_NAME ";

	String SEGSHORTAGEDETECTIONSQL = /* next extent를 일으킬 때, tablespace가 부족한 segment의 정보를 보여줌 */
	"SELECT SEGMENT_NAME, SEGMENT_TYPE, EXTENTS, BYTES/1024 AS SZ_KB, TABLESPACE_NAME, \n" + "NEXT_EXTENT/1024 NEXT_KB,  PCT_INCREASE PCT, INITIAL_EXTENT/1024 INI_KB, \n" + "MAX_EXTENTS MAXEXT \n" + "FROM DBA_SEGMENTS A \n" + "WHERE NOT EXISTS (SELECT 'X' \n" + "                  FROM DBA_FREE_SPACE B  \n" + "                  WHERE A.TABLESPACE_NAME = B.TABLESPACE_NAME   \n" + "                  AND B.BYTES >= A.NEXT_EXTENT)";

	String SEGRBSUSAGESQL = "SELECT A.SEGMENT_NAME AS RB_SEG, \n" + "A.STATUS, C.XACTS AS xT, \n" + "B.INITIAL_EXTENT/1024 AS INI_KB, \n" + "B.NEXT_EXTENT/1024 AS NXT_KB , \n" + "B.EXTENTS AS EXT, \n" + "B.BYTES/1024 AS TOT_KB, \n" + "A.TABLESPACE_NAME AS TBS_NM \n" + "FROM DBA_ROLLBACK_SEGS A, DBA_SEGMENTS B, V$ROLLSTAT C \n" + "WHERE A.SEGMENT_NAME = B.SEGMENT_NAME \n" + "AND   A.SEGMENT_ID   = C.USN \n" + "ORDER BY A.SEGMENT_NAME";

	String SEGRBSWAITRATIOSQL = "SELECT NAME AS RBS_NAME, \n" + "RSSIZE, WRITES, XACTS, STATUS, \n" + "TRUNC(WAITS/GETS*100, 5)||' %' MISS_RATIO \n" + "FROM V$ROLLSTAT, V$ROLLNAME \n" + "WHERE V$ROLLSTAT.USN = V$ROLLNAME.USN \n" + "ORDER BY WAITS/GETS DESC";

	String SEGTABLEUSAGESQL = "SELECT DECODE(SIGN(EXTENTS+10-MAX_EXTENTS),1,'V') as MK, \n" + "OWNER, SEGMENT_NAME OBJECT_NAME, \n" + "INITIAL_EXTENT/1024 AS INI_KB, \n" + "NEXT_EXTENT/1024 AS NXT_KB , \n" + "PCT_INCREASE AS PCT, MAX_EXTENTS AS MAXT, \n" + "EXTENTS AS EXT, \n" + "BYTES/1024 AS TOT_KB, \n" + "TABLESPACE_NAME \n" + "FROM DBA_SEGMENTS \n" + "WHERE OWNER NOT IN ('SYS')  \n" + "AND   SEGMENT_TYPE = 'TABLE' \n" + "AND   EXTENTS >= &extent_num \n" + "AND   SEGMENT_NAME LIKE UPPER('&table_name')||'%' \n" + "ORDER BY OWNER, SEGMENT_NAME";

	String USERGENERALSQL = "SELECT USERNAME, \n" + "DEFAULT_TABLESPACE AS DEF_TBS, \n" + "TEMPORARY_TABLESPACE AS TEMP_TBS, \n" + "PROFILE, \n" + "TO_CHAR(CREATED,'YYYY.MM.DD') AS CREATED \n" + "FROM DBA_USERS";

	String OBJECTSSTATUSPERUSERSQL =
		"SELECT A.OWNER, NVL(A.TAB,0) AS TAB, NVL(A.IDX,0) AS IDX, NVL(A.VEW,0) AS VEW, \n"
			+ "                NVL(A.SYN,0) AS SYN, NVL(A.SEQ,0) AS SEQ, NVL(A.TRG,0) AS TRG, \n"
			+ "                NVL(A.PRO,0) AS PRO, NVL(B.PK,0)  AS PK#, NVL(B.FK,0)  AS FK#, \n"
			+ "                NVL(A.DBL,0) AS DBL, NVL(A.PRO,0) AS PRO, NVL(A.FUN,0) AS FUN, \n"
			+ "                NVL(A.PKG,0) AS PKG, NVL(A.CLU,0) AS CLU, NVL(A.PKB,0) AS PKB \n"
			+ "FROM \n"
			+ "(SELECT OWNER, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'TABLE',1))     AS TAB, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'INDEX',1))     AS IDX, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'VIEW',1))      AS VEW, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'SYNONYM',1))   AS SYN, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'SEQUENCE',1))  AS SEQ, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'TRIGGER',1))   AS TRG, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'DATABASE LINK',1)) AS DBL, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'PROCEDURE',1)) AS PRO, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'FUNCTION',1)) AS FUN, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'PACKAGE',1))   AS PKG, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'PACKAGE BODY',1)) AS PKB, \n"
			+ "        COUNT(DECODE(OBJECT_TYPE,'CLUSTER',1))   AS CLU \n"
			+ "FROM  DBA_OBJECTS \n"
			+ "GROUP BY OWNER ) A, \n"
			+ "(SELECT OWNER, \n"
			+ "        SUM(DECODE(CONSTRAINT_TYPE,'P',1)) AS PK, \n"
			+ "        SUM(DECODE(CONSTRAINT_TYPE,'R',1)) AS FK \n"
			+ " FROM  DBA_CONSTRAINTS \n"
			+ " GROUP BY OWNER ) B \n"
			+ "WHERE A.OWNER = B.OWNER(+) ";

	String OBJECTSTABLESTATUSSQL = "SELECT DECODE(SIGN(EXTENTS+10-MAX_EXTENTS),1,'V') as MK, \n" + "       OWNER, SEGMENT_NAME, \n" + "       INITIAL_EXTENT/1024 AS INI_KB, \n" + "       NEXT_EXTENT/1024 AS NXT_KB , \n" + "       PCT_INCREASE AS PCT, MAX_EXTENTS, \n" + "       EXTENTS,  \n" + "       INITIAL_EXTENT/1024 + NEXT_EXTENT/1024 * ( EXTENTS - 1 ) AS TOT_KB, \n" + "       TABLESPACE_NAME \n" + "FROM DBA_SEGMENTS \n" + "WHERE OWNER NOT IN ('SYS') \n" + "AND   SEGMENT_TYPE = 'TABLE' \n" + "AND   EXTENTS >= &extent_num \n" + "AND   SEGMENT_NAME LIKE UPPER('&table_name')||'%' \n" + "ORDER BY OWNER, SEGMENT_NAME";

	String OBJECTSINDEXCOLUMNSTATUSSQL = "SELECT OWNER,TABLE_NAME,INDEX_NAME, TABLESPACE_NAME \n" + "FROM DBA_INDEXES \n" + "WHERE OWNER NOT IN ('SYS') \n" + "AND   INDEX_NAME NOT LIKE 'PK%' \n" + "ORDER BY OWNER,TABLE_NAME";

	String OBJECTSVIEWSTATUSPERUSERSQL = "SELECT OWNER, OBJECT_NAME, \n" + "OBJECT_TYPE,  STATUS \n" + "FROM DBA_OBJECTS \n" + "WHERE OWNER NOT IN ('SYS') \n" + "AND   OBJECT_TYPE = 'VIEW' \n" + "ORDER BY OWNER,OBJECT_NAME";

	String OBJECTSSTOREDPROCEDURESTATUSSQL = "SELECT OWNER, OBJECT_NAME, OBJECT_TYPE AS TYPE, STATUS \n" + "FROM DBA_OBJECTS \n" + "WHERE OWNER NOT IN ('SYS') \n" + "AND   OBJECT_TYPE IN ('PROCEDURE', 'FUNCTION', 'PACKAGE', 'PACKAGE BODY' ) \n" + "ORDER BY OWNER,OBJECT_TYPE, OBJECT_NAME";

	String OBJECTSTRIGGERSTATUSSQL = "SELECT OWNER,TRIGGER_NAME, TABLE_OWNER,TABLE_NAME,STATUS \n" + "FROM DBA_TRIGGERS \n" + "WHERE OWNER NOT IN ('SYS') \n" + "ORDER BY OWNER,TRIGGER_NAME \n";

	String OBJECTSSEQUENCESTATUSSQL = "SELECT SEQUENCE_OWNER,SEQUENCE_NAME, MIN_VALUE, MAX_VALUE,INCREMENT_BY, \n" + "LAST_NUMBER, CYCLE_FLAG \n" + "FROM DBA_SEQUENCES \n" + "WHERE SEQUENCE_OWNER NOT IN ('SYS') \n" + "ORDER BY SEQUENCE_OWNER,SEQUENCE_NAME";

	String OBJECTSSYNONYMSTATUSSQL =
		"SELECT A.OWNER,A.SYNONYM_NAME, \n"
			+ "A.TABLE_OWNER ,A.TABLE_NAME , \n"
			+ "MAX(DECODE(B.PRIVILEGE,'SELECT','S '))|| \n"
			+ "MAX(DECODE(B.PRIVILEGE,'INSERT','I '))|| \n"
			+ "MAX(DECODE(B.PRIVILEGE,'UPDATE','U '))|| \n"
			+ "MAX(DECODE(B.PRIVILEGE,'DELETE','D '))|| \n"
			+ "MAX(DECODE(B.PRIVILEGE,'REFERENCES','R '))  AS PRIVS, \n"
			+ "MAX(TO_CHAR(C.CREATED,'YYYY.MM.DD')) AS CREATED \n"
			+ "FROM DBA_SYNONYMS A, DBA_TAB_PRIVS B, DBA_OBJECTS C \n"
			+ "WHERE A.OWNER NOT IN ('SYS') \n"
			+ "AND   A.OWNER = B.GRANTEE \n"
			+ "AND   A.OWNER = C.OWNER AND A.SYNONYM_NAME = C.OBJECT_NAME \n"
			+ "AND   C.OBJECT_TYPE = 'SYNONYM' \n"
			+ "AND   A.TABLE_NAME = B.TABLE_NAME \n"
			+ "AND   A.OWNER        LIKE UPPER('&user_name')||'%' \n"
			+ "AND   A.SYNONYM_NAME LIKE UPPER('&synonym_name')||'%' \n"
			+ "GROUP BY A.OWNER, A.SYNONYM_NAME, \n"
			+ "         A.TABLE_OWNER,A.TABLE_NAME";

	String OBJECTSPKCONSTRAINTSQL = "SELECT A.OWNER, A.TABLE_NAME, A.CONSTRAINT_NAME, \n" + "       'PK' AS TYPE, B.TABLESPACE_NAME \n" + "FROM DBA_CONSTRAINTS A, DBA_INDEXES B \n" + "WHERE A.OWNER NOT IN ('SYS') \n" + "AND   A.CONSTRAINT_TYPE IN ('P') \n" + "AND   A.CONSTRAINT_NAME = B.INDEX_NAME(+) \n" + "AND   A.OWNER = B.OWNER(+) \n" + "ORDER BY A.OWNER,A.TABLE_NAME ";

	String OBJECTSFKCONSTRAINTSQL = "SELECT A.OWNER, A.TABLE_NAME, A.CONSTRAINT_NAME, \n" + "       'FK' AS TYPE, \n" + "       DECODE(A.CONSTRAINT_TYPE,'R',A.R_OWNER||'.'|| \n" + "                           B.TABLE_NAME ) AS REF_TABLE, \n" + "       A.STATUS \n" + "FROM DBA_CONSTRAINTS A, DBA_CONSTRAINTS B \n" + "WHERE A.OWNER NOT IN ('SYS') \n" + "AND   A.CONSTRAINT_TYPE IN ('R') \n" + "AND   A.R_OWNER = B.OWNER(+) \n" + "AND   A.R_CONSTRAINT_NAME = B.CONSTRAINT_NAME(+) \n" + "ORDER BY A.OWNER, A.TABLE_NAME ";

	String OBJECTSDBLINKINFOSQL = "SELECT OWNER, \n" + "       DB_LINK, \n" + "       ' USER> '||SUBSTR(NVL(USERNAME,'        ')|| \n" + "       ', HOST> '||HOST,1,22) AS CONN_DB, \n" + "       TO_CHAR(CREATED,'YYYY.MM.DD') AS CREATED \n" + "FROM DBA_DB_LINKS \n" + "ORDER BY OWNER, DB_LINK ";

	String TABLEESTIMATEDSIZESQL = "SELECT A.OWNER,A.TABLE_NAME, A.AVG_ROW_LEN AS ,A.NUM_ROWS , \n" + "A.TABLESPACE_NAME, \n" + "A.CLUSTER_NAME , \n" + "TO_CHAR(B.CREATED,'YYYY.MM.DD') AS CREATED \n" + "FROM DBA_TABLES A, DBA_OBJECTS B \n" + "WHERE A.OWNER NOT IN ('SYS') \n" + "AND   A.OWNER = B.OWNER AND A.TABLE_NAME = B.OBJECT_NAME \n" + "AND   A.TABLE_NAME LIKE UPPER('&table_name')||'%' \n" + "ORDER BY A.OWNER,A.TABLE_NAME";

	String TABLEDESCSQL =
		"SELECT OWNER,ID,COLUMN_NAME,PK,NN,DATA_TYPE,DATA_LENG,PI,I1,I2,I3,I4,ICNT \n"
			+ "FROM ( \n"
			+ "      SELECT MAX(DECODE(FLAG,'P','P',' ')) AS PK, \n"
			+ "             OWNER,COLUMN_NAME, \n"
			+ "             MAX(DECODE(NULLABLE,'N','Y',NULL)) as NN, \n"
			+ "             MAX(DATA_TYPE) AS DATA_TYPE, \n"
			+ "             MIN(DATA_LENG) AS DATA_LENG, \n"
			+ "             MAX(DECODE(FLAG,'P','I')) AS FLAG, \n"
			+ "             MIN(DECODE(FLAG,'P',IDX_ID)) AS PI, \n"
			+ "             MIN(DECODE(FLAG||IX,'I1',IDX_ID)) AS I1, \n"
			+ "             MIN(DECODE(FLAG||IX,'I2',IDX_ID)) AS I2, \n"
			+ "             MIN(DECODE(FLAG||IX,'I3',IDX_ID)) AS I3, \n"
			+ "             MIN(DECODE(FLAG||IX,'I4',IDX_ID)) AS I4, \n"
			+ "             MAX(COLUMN_ID) AS ID, \n"
			+ "             COUNT(DECODE(FLAG,'I',1,'P',1)) AS ICNT \n"
			+ "     FROM ( SELECT OWNER , COLUMN_NAME, '' AS FLAG, DATA_TYPE, \n"
			+ "                  '('||DECODE(DATA_TYPE,'NUMBER',NVL(DATA_PRECISION,DATA_LENGTH),DATA_LENGTH) \n"
			+ "                  ||DECODE(DATA_TYPE,'NUMBER', \n"
			+ "                  DECODE(DATA_SCALE,NULL,')',','||TO_CHAR(DATA_SCALE)||')'),')') \n"
			+ "                  DATA_LENG, \n"
			+ "                  NULLABLE,COLUMN_ID, NULL AS IX, 0 AS IDX_ID \n"
			+ "            FROM DBA_TAB_COLUMNS \n"
			+ "            WHERE TABLE_NAME = UPPER('&table_name') \n"
			+ "            UNION ALL \n"
			+ "            SELECT B.INDEX_OWNER,B.COLUMN_NAME, \n"
			+ "                   DECODE(A.CONSTRAINT_TYPE,'P','P','I' ) AS FLAG,'', \n"
			+ "                   '0' , '' , 0, \n"
			+ "                   SUBSTR(INDEX_NAME,-1,1) AS IX,COLUMN_POSITION AS IDX_ID \n"
			+ "            FROM  DBA_CONSTRAINTS A, DBA_IND_COLUMNS B \n"
			+ "            WHERE A.CONSTRAINT_NAME(+) = B.INDEX_NAME \n"
			+ "            AND   A.OWNER (+)          = B.INDEX_OWNER \n"
			+ "            AND   B.TABLE_NAME = UPPER('&table_name') \n"
			+ "            ) \n"
			+ "            GROUP BY OWNER,COLUMN_NAME ) \n"
			+ "     ORDER BY OWNER,ID ";

	String TABLEREALSIZESQL = "SELECT A.TABLE_NAME AS TNAME, B.BYTES/1024. AS TOTAL_KB, B.EXTENTS , \n" + "       ROUND((A.BLOCKS * A.AVG_SPACE + A.EMPTY_BLOCKS * &db_block_size)/1024.,1) FREE_SZ_KB,  \n" + "       ROUND((B.BYTES - (A.BLOCKS * A.AVG_SPACE + A.EMPTY_BLOCKS * &db_block_size))/1024.,1) REAL_SZ_KB \n" + "FROM DBA_TABLES A, DBA_SEGMENTS B \n" + "WHERE A.OWNER = B.OWNER \n" + "AND A.TABLE_NAME = B.SEGMENT_NAME \n" + "AND A.OWNER LIKE UPPER('&user_name') \n" + "AND A.TABLE_NAME LIKE UPPER('&table_name')";

	String TABLEFREESPACESQL = "SELECT TABLE_NAME AS TNAME, EMPTY_BLOCKS, BLOCKS, AVG_SPACE, \n" + "       ROUND((BLOCKS * AVG_SPACE + EMPTY_BLOCKS * &db_block_size)/1024.,1) FREE_KB \n" + "FROM DBA_TABLES \n" + "WHERE OWNER LIKE UPPER('&user_name') \n" + "AND TABLE_NAME LIKE UPPER('&table_name')";

	String INDEXLISTSQL = "SELECT A.OWNER,A.TABLE_NAME,A.INDEX_NAME, A.TABLESPACE_NAME, \n" + "TO_CHAR(B.CREATED,'YYYY.MM.DD') AS CREATED \n" + "FROM DBA_INDEXES A, DBA_OBJECTS B \n" + "WHERE A.OWNER NOT IN ('SYS') \n" + "AND   A.OWNER = B.OWNER AND A.INDEX_NAME = B.OBJECT_NAME \n" + "AND   A.OWNER LIKE UPPER('&user_name')||'%' \n" + "AND   A.TABLE_NAME LIKE UPPER('&table_name')||'%' \n" + "ORDER BY A.OWNER,A.TABLE_NAME";

	String INDEXCOLUMNLISTSQL = "SELECT TABLE_OWNER AS OWNER,TABLE_NAME,INDEX_NAME, \n" + "COLUMN_POSITION AS ID,COLUMN_NAME \n" + "FROM DBA_IND_COLUMNS \n" + "WHERE TABLE_OWNER NOT IN ('SYS') \n" + "AND   TABLE_OWNER LIKE UPPER('&user_name')||'%' \n" + "AND   TABLE_NAME  LIKE UPPER('&table_name')||'%' \n" + "ORDER BY TABLE_OWNER,TABLE_NAME,INDEX_NAME,COLUMN_POSITION";

	String INDEXUSAGESQL = "SELECT DECODE(SIGN(EXTENTS+10-MAX_EXTENTS),1,'V') as MK, \n" + "OWNER, SEGMENT_NAME AS OBJECT_NAME, \n" + "INITIAL_EXTENT/1024 AS INI_KB, \n" + "NEXT_EXTENT/1024 AS NXT_KB , \n" + "PCT_INCREASE AS PCT, MAX_EXTENTS AS MAXT, \n" + "EXTENTS AS EXT,  \n" + "BYTES/1024 AS TOT_KB, \n" + "TABLESPACE_NAME \n" + "FROM DBA_SEGMENTS \n" + "WHERE OWNER NOT IN ('SYS') \n" + "AND   SEGMENT_TYPE = 'INDEX' \n" + "AND   EXTENTS >= &extent_num \n" + "AND   SEGMENT_NAME LIKE UPPER('&index_name')||'%' \n" + "ORDER BY OWNER, SEGMENT_NAME ";

	String CONSTRAINTCOLUMNLISTSQL = "SELECT A.OWNER, A.TABLE_NAME, A.CONSTRAINT_NAME AS CONS, A.COLUMN_NAME, \n" + "B.CONSTRAINT_TYPE AS CONS_TYPE, B.R_OWNER, B.R_CONSTRAINT_NAME AS R_CONS, \n" + "B.DELETE_RULE, B.STATUS, B.SEARCH_CONDITION AS CONDITION \n" + "FROM DBA_CONS_COLUMNS A, DBA_CONSTRAINTS B \n" + "WHERE A.OWNER = B.OWNER \n" + "AND   A.TABLE_NAME = B.TABLE_NAME \n" + "AND   A.CONSTRAINT_NAME = B.CONSTRAINT_NAME \n" + "AND   A.OWNER LIKE UPPER('&user_name') \n" + "AND   A.TABLE_NAME LIKE UPPER('&table_name') \n" + "ORDER BY POSITION";

	String CONSTRAINTREFERENCINGTABLESQL = "SELECT A.OWNER, A.OBJECT_NAME, C.NAME  CONSTRAINT_NAME \n" + "FROM DBA_OBJECTS A, SYS.CDEF$ B, SYS.CON$ C \n" + "WHERE A.OWNER LIKE UPPER('&owner') \n" + "AND A.OBJECT_NAME LIKE UPPER('&tname') \n" + "AND A.OBJECT_ID = B.ROBJ# \n" + "AND B.CON#      = C.CON#";

	String SESSIONSQLSQL = "SELECT S.USERNAME, S.OSUSER, A.SQL_TEXT \n" + "FROM V$SQLTEXT A, V$SESSION S \n" + "WHERE S.SID = &sid \n" + "AND S.SERIAL# = &serial \n" + "AND A.ADDRESS = S.SQL_ADDRESS \n" + "AND A.HASH_VALUE = S.SQL_HASH_VALUE \n" + "ORDER BY A.PIECE";

	String SESSIONOBJECTSQL = "SELECT SUBSTR(B.PROCESS,1,5) AS PGM_PS, SUBSTR(B.MACHINE,1,12) AS MACHINE, \n" + "       SUBSTR(B.PROGRAM,1,15) AS PROGRAM, B.SID, B.SERIAL# AS SER#, \n" + "       B.STATUS, \n" + "       DECODE(C.OWNER,NULL,' X ',SUBSTR(C.OWNER||'.'||C.OBJECT,1,22)) as OWN_OBJECT \n" + "FROM  V$SESSION B, V$ACCESS C \n" + "WHERE B.SID = C.SID(+) \n" + "AND   B.USERNAME IS NOT NULL \n" + "AND   B.SID LIKE '&S_ID'||'%' \n" + "AND   B.PROCESS = DECODE(&PGM_PROCS,'0',B.PROCESS,&PGM_PROCS) \n" + "AND   B.MACHINE LIKE '&vMACHINE'||'%' \n" + "AND   ( C.OBJECT  LIKE UPPER('&vOBJECT')||'%' OR C.OBJECT IS NULL ) \n" + "ORDER BY PROGRAM";

	String SESSIONSTATUSSQL = "SELECT SUBSTR(MACHINE,1,12) AS MACHINE,substr(PROGRAM,1,15) AS PROGRAM, \n" + "       TO_CHAR(LOGON_TIME,'MM.DD HH24:MI') AS LOGON_TIME, \n" + "       SERVER, \n" + "       STATUS, \n" + "       PROCESS AS PGM_PS, SID,SERIAL# \n" + "FROM V$SESSION \n" + "WHERE TYPE != 'BACKGROUND' \n" + "AND   PROCESS = DECODE(&PGM_PROCS,'0',PROCESS,&PGM_PROCS) \n" + "AND   SID LIKE '&S_ID'||'%' \n" + "order by 3 ";

}
